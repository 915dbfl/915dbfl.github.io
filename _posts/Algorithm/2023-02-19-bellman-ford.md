---
title: "[Algorithm] Bellman-Ford"
excerpt: "μμ κ°„μ„ μ΄ μ΅΄μ¬ν•  λ• μµλ‹¨κ±°λ¦¬ μ°ΎκΈ°"
categories:
  - Algorithm
tag:
  - algorithm
  - bellman ford

last_modifeid_at: 2023-02-19
toc: true
toc_sticky: true
search: true
---


## π™ λ²¨λ§ν¬λ“(Bellman-Ford)?
λ²¨λ§ν¬λ“μ κ²½μ°μ—λ„ λ‹¤μµμ¤νΈλΌμ™€ λ§μ°¬κ°€μ§€λ΅ **μ‹μ‘ μ •μ μΌλ΅λ¶€ν„° λ‹¤λ¥Έ μ •μ κΉμ§€μ μµλ‹¨ κ²½λ΅**λ¥Ό κµ¬ν•λ” μ•κ³ λ¦¬μ¦μ΄λ‹¤.

<br>

## π™ λ²¨λ§ν¬λ“ νΉμ§•
* **μμ κ°€μ¤‘μΉ**κ°€ μλ” κ·Έλν”„μ—μ„μ μµλ‹¨ κ±°λ¦¬λ¥Ό κµ¬ν•  μ μλ‹¤.
* μμ κ°€μ¤‘μΉλ΅ μΈν• **μμ μ‚¬μ΄ν΄ μ΅΄μ¬ μ—¬λ¶€**λ¥Ό μ• μ μλ‹¤.

<br>

## π™ μμ μ‚¬μ΄ν΄ μ—¬λ¶€λ” μ–΄λ–»κ² μ• μ μμ„κΉ?
κ·Έλ ‡λ‹¤λ©΄ μμ μ‚¬μ΄ν΄ μ΅΄μ¬ μ—¬λ¶€λ¥Ό μ–΄λ–»κ² ν™•μΈν•λ” κ²ƒμΌκΉ?
* μ „μ²΄ μ½”λ“μ λ°λ³µμ„ **V-1**λ§ μ§„ν–‰ν•λ‹¤.
* **μ •μ μ κ°μκ°€ VμΌ λ•** μ‹μ‘ μ •μ μ—μ„ νΉμ • μ •μ κΉμ§€ λ„λ‹¬ν•κΈ° μ„ν•΄ κ±°μΉ  μ μλ” **μµλ€ κ°„μ„ μ κ°μλ” V-1**μ΄κΈ° λ•λ¬Έμ΄λ‹¤.
* λ”°λΌμ„ Vλ²μ§Έ κ°„μ„ μ΄ μ΅΄μ¬ν•λ‹¤λ©΄ μ΄λ” μμ μ‚¬μ΄ν΄λ΅ νλ‹¨λλ‹¤.

<br>

## π™ μ§„ν–‰ κ³Όμ •
μ½”λ“λ¥Ό λ³΄κΈ° μ „μ— μ§„ν–‰ κ³Όμ •μ„ ν• λ² μ§κ³  λ„μ–΄κ°€μ!!
1. μ‹μ‘ μ •μ μ„ μ μ™Έν•κ³  λ‹¤λ¥Έ μ •μ κΉμ§€μ κ±°λ¦¬λ¥Ό λ¨λ‘ λ¬΄ν•μΌλ΅ μ΄κΈ°ν™”ν•λ‹¤.
2. μ •μ  μ(v-1) λ§νΌ λ‹¤μμ κ³Όμ •μ„ λ°λ³µν•λ‹¤.
  * ν• λ²μ λ°λ³µλ§λ‹¤ λ¨λ“  κ°„μ„ μ„ ν™•μΈν•λ‹¤.
  * ν„μ¬ μ •μ μ—μ„ μΈμ ‘ν• λ¨λ“  μ •μ μ„ νƒμƒ‰ν•λ‹¤.
  * κΈ°μ΅΄ μ €μ¥λμ–΄ μλ” μΈμ ‘ μ •μ κΉμ§€μ κ±°λ¦¬λ³΄λ‹¤ ν„μ¬ μ •μ μ„ κ±°μ³ μ΄λ™ν•λ” κ±°λ¦¬κ°€ λ” μ§§μ„ κ²½μ° κ°±μ‹ ν•λ‹¤.
3. λ§μ§€λ§‰ v-1 λ°λ³µ ν›„μ—λ„ κ±°λ¦¬κ°€ κ°±μ‹ λλ‹¤λ©΄ μμ μν™μ΄ μ΅΄μ¬ν•λ” κ²ƒμΌλ΅ νλ‹¨ν•λ‹¤.

<br>

κ·Έλ ‡λ‹¤λ©΄ μ΄μ  μ½”λ“λ¥Ό ν†µν•΄ λ‹¤μ‹ ν• λ² κ·Έ κ³Όμ •μ„ ν™•μΈν•΄λ³΄μ!!

```python
import sys
input = sys.stdin.readline
INF = int(1e9) 

v, e = map(int, input().split())
edges = []
dist = [INF] * (v+1) # λ¬΄ν•λ€λ΅ κ±°λ¦¬ μ΄κΈ°ν™”

for _ in range(e):
    u, v, w = map(int, input().split())
    edges.append((u, v, w))

def bellmanFord(start):
    dist[start] = 0 # μ‹μ‘ μ •μ  κ±°λ¦¬ 0μΌλ΅ μ΄κΈ°ν™”

    # μµλ€ κ°„μ„ μ κ°μ + 1μΈ v λ§νΌ λ°λ³µμ„ μν–‰
    # λ§μ§€λ§‰ vλ² μ§Έμ— λ³€κ²½λλ‹¤λ©΄ negative cycle!
    for i in range(v):
        # λ§¤ λ°λ³µλ§λ‹¤ λ¨λ“  κ°„μ„  ν™•μΈ
        for j in range(e):
            node = edges[j][0]
            next_node = edges[j][1]
            cost = edges[j][2]
            
            # ν„μ¬ κ°„μ„ μ„ κ±°μ³ μ΄λ™ν•λ” κ±°λ¦¬κ°€ λ” μ§§μ„ κ²½μ°
            if dist[node] != INF and dist[next_node] > dist[node] + cost:
                dist[next_node] = dist[node] + cost

                # vλ²μ§Έμ— κ°±μ‹ λλ” κ°’μ΄ μμ„ κ²½μ° negative cycle!
                if i == v-1:
                    return True
    return False

if bellmanFord(1):
    for i in range(2, v+1):
        if dist[i] == INF:
            print("λ„λ‹¬ν•  μ μ—†λ‹¤.")
        else:
            print(dist[i])
else:
    print("Negative Cycle Exist")
```

<br>

## π‘€ λ‹¨μ μμ μ‚¬μ΄ν΄λ§ ν™•μΈν•λ” κ²½μ°λΌλ©΄?
μ‹μ‘ μ •μ μΌλ΅ λ¶€ν„° μµλ‹¨ κ±°λ¦¬λ¥Ό ν™•μΈν•λ” κ²ƒμ΄ μ•„λ‹ **κ·Έλν”„ μƒμ— μμ μ‚¬μ΄ν΄ μ΅΄μ¬ μ—¬λ¶€λ§μ„ ν™•μΈ**ν•λ©΄ λλ” κ²½μ°!

κµ³μ΄ μ‹μ‘ μ •μ μ„ λ‘ ν•„μ”κ°€ μ—†μ–΄μ§„λ‹¤!!

λ”°λΌμ„ **μ‹μ‘ μ •μ κ³Ό μΈμ ‘ν• μ •μ μΈμ§€ νλ‹¨ν•λ” λ¶€λ¶„μ„ μ—†μ• λ©΄ λλ” κ²ƒμ΄λ‹¤!**

```python
    if dist[next_node] > dist[node] + cost:
```

<br>

## π™ μ‹κ°„λ³µμ΅λ„
* κ° λ°λ³µλ§λ‹¤ λ¨λ“  κ°„μ„ μ„ ν™•μΈν•λ‹¤. (E)
* μ •μ μ κ°μ λ§νΌ λ°λ³µμ„ μ§„ν–‰ν•λ‹¤. (V)

-> O(VE)

<br>

# π“ μ°Έκ³  μλ£
* <https://velog.io/@younge/Python-μµλ‹¨-κ²½λ΅-λ²¨λ§-ν¬λ“Bellman-Ford-μ•κ³ λ¦¬μ¦>
* <https://deep-learning-study.tistory.com/587>
* <https://headf1rst.github.io/algorithm/bellmanford/>