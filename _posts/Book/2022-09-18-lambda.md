---
title: "[Kotlin in action] 5장: 람다로 프로그래밍"
excerpt: "람다/컬렉션 함수형 API"
categories:
  - Book
tag:
  - kotlin lambda
  - kotlin in action
  - sequence

last_modified_at: 2022-09-18
toc: true
toc_sticky: true
search: true
---

🙂 이전부터 차근차근 읽고 있었던 'Kotlin in action' 책을 본격적으로 정리하고자 한다.

단순히 읽는 것으로는 오래 기억되지 않을 것 같아 두고두고 볼 수 있도록 기록 해야겠다!!


<br>

# 👩 람다

> 람다? 다른 함수에 넘길 수 있는 작은 코드 조각

## 🙋‍♀️ 람다식

> {x: Int, y: Int -> x+y}

* 항상 **중괄호 사이**에 식이 위치한다.

> run{ println(42) }

* 람다를 직접 호출하는 것보다 **run**을 사용해 람다 본문을 실행하는 것이 더 좋다.

```kotlin
val sum = {x: Int, y: Int ->
  println("Computing the sum of $x and $y...")
  x+y //결과 값
  }
```
* 여러 줄의 람다식에서는 **마지막 식**이 결과 값이 된다.

<br>

## 🙋‍♀️ 람다와 멤버 참조(::)

함수의 인자로 다음의 람다식을 넘기는 경우, `{p -> p.age}`, 함수가 중복된다는 것을 알 수 있다. 이럴 때 사용할 수 있는 것이 바로 **멤버 참조**이다.

> Person::age

### 🙌 생성자 참조
  * **생성자 참조**를 통해서 <u>클래스의 생성을 연기/저장</u>할 수 있다.

  ```kotlin
  data class Person(val name: String, val age: Int)
  ...
  val createPerson = ::Person // 생성자 참조
  val p = createPerson("Alice", 23) // Person(name=Alice, age=23)
  ```

<br>

# 👩 컬렉션 함수형 API

지금부터 컬렉션을 다루는 코틀린 표준 라이브러리 중 몇 가지를 살펴보고자 한다.

## 🙋‍♀️ filter & map
* **filter**: 주어진 람다에 만족하는 원소만을 모아 반환
  ```kotlin
    val list = listOf(1, 2, 3, 4)
    println(list.filter{it % 2 == 0}) // 2, 4
  ```
  * 함수의 단 하나의 인자가 람다일 경우 밖으로 꺼내 작성할 수 있다.

* **map**: 모든 원소에 적용한 결과를 모아 새 컬렉션으로 만들어 반환
  ```kotlin
    val list = listOf(1, 2, 3, 4)
    println(list.map{it*it}) // [1, 4, 9, 16]
  ```

* 두 연산을 **연쇄**시킬 수도 있다.
  ```kotlin
    val list = listOf(1, 2, 3, 4)
    print(list.filter{it % 2 == 0}.map{it * it}) // [4, 16]
  ```

* **컬렉션 map**에서의 filter, map
  * **filterKeys / filterValues**: 각각 맵의 키와 값을 걸러내는 역할
  * **mapKeys / mapValues**: 각각 맵의 키와 값을 변환하는 역할

  ```kotlin
    val numbers = mapOf(0 to "zero", 1 to "one")
    println(numbers.mapValues{it.value.toUpperCase()}) // {0 = ZERO, 1 = ONE}
  ```

<BR>

## 🙋‍♀️ all & any & count & find

* **all / any**: 각각 컬렉션에서 조건을 모두/일부 만족하는 지 판단
* **count**: 컬렉션에서 조건을 만족하는 원소의 **개수**를 반환
* **find**: 컬렉션에서 조건을 만족하는 **첫 번째 원소**를 반환
  * 해당하는 원소가 없을 경우, **null**을 반환한다. (= findOrNull)

```kotlin
  val canBeInClub27 = {p: Person -> p.age <= 27} // 술어 함수
  val people = listOf(Person("Alice", 27), Person("Bob", 31))

  println(people.all(canBeInClub27)) // false
  println(people.any(canBeInClub27)) // true
  println(people.count(canBeInClub27)) // 1
  println(people.find(canBeInClub27)) // Person("Alice", 27)
```
<br>

## 🙋‍♀️ groupBy
* 리스트를 하나의 특징을 키로 한 **맵**으로 변환해 반환한다.

```kotlin
  val list = listOf("a", "ab", "b")
  println(list.groupBy{String::first}) # {a= [a, ab], b= [b]}
```
* 각 그룹의 값은 **리스트**이다.
* 위 예시에서 `String::firs`t는 확장 함수를 멤버 참조를 통해 사용했다.

<br>

## 🙋‍♀️ flatten & flatMap
* **중첩 컬렉션**의 원소들을 **하나의 리스트**로 만든다.
* **flatten**: 단순히 중첩 컬렉션을 하나의 리스트로 만든다.
* **flatMap**: **람다를 적용**해 얻어지는 여러 리스트를 하나로 모은다.

```kotlin
  val strings = listOf("abc", "def")
  println(strings.falttenMap{it.toList()}) // [a, b, c, d, e, f]
```

<br>

# 👩 시퀀스를 이용한 컬렉션의 지연 연산

다음과 같은 연쇄 연산을 살펴보자!

## 🙋‍♀️ 컬렉션에서의 연쇄 연산

```kotlin
  list.filter{it % 2 == 0}.map{it * it}
```
* 여기서 주의해야 할 점은 filter, map 모두 결과로 <u>리스트를 반환</u>한다는 점이다.
* 즉, 연쇄 매 단계마다 **중간 결과가 새로운 컬렉션에 임시로 저장**된다. (즉시 계산)

만약 리스트의 원소가 수백만 개가 된다면 매 단계마다 수백만 원소의 리스트가 생성되는 것이다. 이러한 문제점을 해결하는 것이 바로 **시퀀스**이다.

<BR>

## 🙋‍♀️ 시퀀스에서의 연쇄 연산

```kotlin
  list.asSequence().filter{it % 2 == 0}.map{it * it}.toList()
```
* 중간 결과를 저장하는 컬렉션이 생성되지 않는다. (지연 계산)
* 결과를 이터레이션에만 사용한 다면 list로 변환하지 않아도 된다. 단, 인덱스를 사용해 접근하는 등의 다른 API 메서드를 사용할 경우 리스트로 변환해야 한다.

<BR>

### ➕ 연산 순서에 따른 성능 차이

컬렉션에 대해 수행하는 연산 순서에 따라서 성능의 차이가 발생한다. 다음의 경우를 살펴보자.

```kotlin
  val people = listOf("Alice", 27), Person("Bob", 31), Person("Charles", 31), Person("Dan", 21))

  // map -> filter
  println(people.asSequence().map(Person::name).filter{it.length < 4}.toList()) # [Bob, Dan]

  // filter -> map
  println(people.asSequence().filter{it.name.length < 4}.map(Person::name)) # [Bob, Dan]
```

결과는 똑같지만 변환 횟수를 살펴보면 어느 연산을 먼저 하는 것이 효율적인 지를 파악할 수 있다.

<img src = "https://drive.google.com/uc?export=view&id=1_ZvNNvhOpexfoRVTK--RmSSu-mgLutln" width = 600 height = 500>

* map 연산을 먼저 할 경우 모든 원소를 변환하지만 filter를 먼저 적용하면 부적절한 원소는 제외하게 된다.

<br>

## 🙋‍♀️ 시퀀스 지연 연산
* 시퀀스의 원소는 **필요할 때 비로소 계산된다.**

```kotlin
  listOf(1, 2, 3, 4).asSequence()
    .map{print("map($it) "); it * it} // 중간 연산
    .filter{print("filter($it) "); it % 2 == 0} // 중간 연산
    .toList() //최종 연산
```

시퀀스 연산은 중간 연산과 최종 연산으로 나뉜다.

🙄 위의 식에서 최종연산이 없다면 **아무 것도 출력되지 않는다.** **최종 연산이 호출될 때 연기됐던 중간연산이 비로소 진행**되어 출력 결과를 볼 수 있게 된다. 여기서 또 주목해야 할 점은 연산의 수행 순서이다. 출력 결과를 통해서 수행 순서를 확인해보자.

> map(1) filter(1) map(2) filter(4) map(3) filter(9) map(4) filter(16)

* 연산이 각 원소에 대해 **🔔순차적으로** 적용된다.
* 컬렉션 연쇄 연산에서는 map을 통한 새 시퀀스를 얻고, 그 시퀀스에 대해 filter를 수행하게 된다.

```kotlin
  println(listOf(1, 2, 3, 4).asSequence()
    .map{it * it}.find{it > 3}) // 4
```
위 식이 수행되는 과정을 통해 즉시 게산과 지연 계산의 차이를 명확히 알아보자!

<img src = "https://drive.google.com/uc?export=view&id=1m2DDeWVmk5dg25c1w1wdsMPvoNHc4v0F" width = 600 height = 500>

* **즉시 연산**은 **컬렉션**에 연산을 적용한다.
* **지연 연산**은 원소 **하나**씩 연산을 진행한다.

<br>

## 🙋‍♀️ generateSequence로 시퀀스 생성

위의 경우 기존의 컬렉션에 `asSequence()`를 통해서 시퀀스를 생성했다. 하지만 <u>직접 시퀀스를 생성하는 방법</u>도 있다. 아래의 0-100까지의 합을 구하는 코드를 살펴보자!

```kotlin
  val naturalNumbers = generateSequnece(0) {it + 1}
  val numbersTo100 = naturalNumbers.takeWhile {it <= 100}
  println(numbersTo100.sum()) #5050
```
* naturalNumbers, numbersTo100 시퀀스 모두 **최종 연산인 sum이 수행될 때** 계산이 된다.
* `generateSequence()` 함수는 **이전 원소를 인자로 받아 다음 원소를 계산한다.**
* 시퀀스는 일반적으로 객체의 조상으로 이뤄진 시퀀스를 만들어 조상의 특성을 알고 싶을 때 사용한다.
  * ex) 특정 파일의 상위 디렉터리를 검사하며 숨김 속성을 가진 디렉터리가 있는지 확인한다.


<br>

# 👩 함수형 인터페이스를 대신하는 람다


## 🙋‍♀️ 함수형/SAM 인터페이스
버튼에 리스너를 다는 작업을 살펴보자!

```java
  button.setOnClickListener(new OnClickListener(){
    @Override
    public void onClick(View v){
      ...
    }
  })
```
 자바에서는 setOnClickListener 메서드에 인자로 위와 같이 **무명클래스**를 넘겼었다.

> 여기서 onClickListener는 **추상 메서드**가 onClick **단 하나**만 존재한다. 이러한 인터페이스를 `함수형 인터페이스`라고 한다.

🙄 코틀린에서는 이렇게 **함수형 인터페이스를 인자로 취하는 자바 메서드**를 호출할 때 **람다**로 대체할 수 있다.

```kotlin
  button.setOnClickListener {view -> ...}
```

<br>


🙇‍♀️ 학습하며 계속해서 추가하고 있습니다! 부족한 부분이 있다면 말씀해주세요! 감사합니다!



## 📃참고
* 'Kotlin in action': 5장(람다로 프로그래밍)